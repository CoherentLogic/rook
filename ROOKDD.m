ROOKDD
 Q
 ;
MKNEST(NEST,RESULT)
 ;
 ; SUBROUTINE DATA
 ;
 N GLVN,TIMER,QRYTIME,DAT,NERES,NERET
 S (RKRESULT,DAT(0))=1
 S TIMER=$$BTIME^ROOK
 ; 
 ; REQUIRE AN ACTIVE ROOK CONNECTION
 ; 
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 G:RKRESULT=0 ERMKNEST
 S RKRESULT=1
 ;
 ; MAKE THE NEST IF THE NEST DOES NOT ALREADY EXIST
 ;
 S NERET=$$NESTEXISTS(NEST,.NERES)
 I NERES("RETURN")=0 D
 . S GLVN="^"_NEST
 . BREAK
 . L (^ROOK("DD",NEST),@GLVN@("DATA"),@GLVN@("INDEX")):30
 . I $TEST D
 . . S ^ROOK("DD",NEST)=""
 . . S @GLVN@("DATA")="",@GLVN@("INDEX")=""
 . E  D
 . . D ERR^ROOK(20,.RESULT)
 . I RKRESULT=1 D
 . . L 
 . . S QTIME=$$ETIME^ROOK(TIMER)
 . . D SUCCESS^ROOK(.RESULT,0,QTIME,1,.DAT)
 E  D
 . D ERR^ROOK(1,.RESULT)
ERMKNEST
 Q RKRESULT
 ;
MKEGG(EGGDEF,RESULT)
 ; 
 ; EGG ATTRIBUTES
 ;
 N EGGNAME,EMBDEF,ENTNUM
 ;
 ; SUBROUTINE DATA
 ;
 N TIMER,DATA
 S DATA(0)=1,EGGNAME=""
 ;
 ; INITIALIZE QUERY TIMER 
 ;
 S TIMER=$$BTIME^ROOK
 ;
 ; REQUIRE AN ACTIVE ROOK CONNECTION AND SELECTED NEST
 ;
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 G:RKRESULT=0 ERMKEGG
 S RKRESULT=1
 I $$USED^ROOK="" D
 . D ERR^ROOK(10,.RESULT)
 G:RKRESULT=0 ERMKEGG
 S RKRESULT=1
 ;
 ; SET UP DATA STRUCTURES
 ; 
 S EGGNAME=$O(EGGDEF(EGGNAME))
 S ENTNUM=EGGDEF(EGGNAME,"ENTRYNUMBER")
 ;
 ; FAIL IF EGG ALREADY EXISTS
 ;
 N EGGEXRES,EGGEXRET
 S EGGEXRET=$$EGGEXISTS^ROOKDD(EGGNAME,.EGGEXRET)
 I EGGEXRET("RETURN")=1 D
 . D ERR^ROOK(11,.RESULT)
 G:RKRESULT=0 ERMKEGG
 S RKRESULT=1
 ;
 ; CREATE THE DATA DICTIONARY ENTRY FOR THE EGG
 ;
 L ^ROOK("DD",$$CURRENTNEST^ROOK,EGGNAME):30
 I $TEST D
 . S ^ROOK("DD",$$CURRENTNEST^ROOK,EGGNAME,"ENTRYNUMBER")=ENTNUM
 E  D
 . D ERR^ROOK(20,.RESULT)
 G:RKRESULT=0 ERMKEGG
 L 
 S RKRESULT=1
 ;
 ; CREATE ANY DEFINED EMBRYOS
 ;
 N EMBDEFS M EMBDEFS=EGGDEF(EGGNAME,"EMBRYOS")
 N MKEMBRET,MKEMBRES
 S MKEMBRET=$$MKEMBRYO(EGGNAME,.EMBDEFS,.MKEMBRES)
 ;
 ; PASS ANY ERRORS FROM $$MKEMBRYO THROUGH TO CALLER
 ;
 I MKEMBRES("ERROR","CODE")>0 D
 . D ERR^ROOK(MKEMBRES("ERROR","CODE"),.RESULT)
 G:RKRESULT=0 ERMKEGG
 S RKRESULT=1
 ;
 ; BUILD THE RETURN ARRAY AND QUIT
 ;
 D SUCCESS^ROOK(.RESULT,1,$$ETIME^ROOK(TIMER),MKEMBRES("RECORDCOUNT")+1,.DATA) 
ERMKEGG
 Q RKRESULT
 ; 
MKEMBRYO(EGGNAME,EMBDEF,RESULT)
 ;
 ; DATA ATTRIBUTES
 ;
 N EMBNAME,TYPE,UNIQUE,REQ,PATTERN,IXF,OXF,PRIMARY,NEST,EMBCT,ERRCT,MAXLENGTH
 S (EMBNAME,TYPE,PATTERN,IXF,OXF)=""
 S (UNIQUE,REQ,PRIMARY,EMBCT,ERRCT)=0
 S NEST=$$CURRENTNEST^ROOK
 ;
 ; SUBROUTINE DATA
 ;
 N TIMER,DATA,EMBEXRES,EMBEXRET
 S DATA(0)=1
 ;
 ; INITIALIZE QUERY TIMER 
 ;
 S TIMER=$$BTIME^ROOK
 ;
 ; REQUIRE CONNECTION TO ROOK
 ;
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 G:RKRESULT=0 ERMKEMBRYO
 S RKRESULT=1
 ;
 ; REQUIRE SELECTED NEST
 ; (SUCCESS HERE IMPLIES THAT THE NEST EXISTS)
 ;
 I NEST="" D
 . D ERR^ROOK(10,.RESULT)
 G:RKRESULT=0 ERMKEMBRYO
 S RKRESULT=1
 ; 
 ; MAKE SURE EGG EXISTS 
 ;
 N EGGEXRES,EGGEXRET
 S EGGEXRET=$$EGGEXISTS(EGGNAME,.EGGEXRES)
 I EGGEXRES("RETURN")=0 D 
 . D ERR^ROOK(12,.RESULT)
 G:RKRESULT=0 ERMKEMBRYO
 S RKRESULT=1
 ; 
 ; LOOP OVER THE EMBRYOS DEFINED IN THE EMBRYO DEFINITION
 ;
 S EMBNAME=""
 F  S EMBNAME=$O(EMBDEF(EMBNAME)) Q:EMBNAME=""  D
 . ;
 . ; ENSURE THE EMBRYO DOES NOT ALREADY EXIST
 . ;
 . K EMBEXRES
 . S EMBEXRET=$$EMBRYOEXISTS(EGGNAME,EMBNAME,.EMBEXRES)
 . I EMBEXRES("RETURN")=1 D
 . . D ERR^ROOK(8,.RESULT)
 . ;
 . ; VALIDATE THE EMBRYO NAME
 . ;
 . I $$VALNAME^ROOK(EMBNAME)=0 D
 . . D ERR^ROOK(15,.RESULT)
 . ; 
 . ; PULL IN THE DATA
 . ;
 . S EMBCT=EMBCT+1
 . S TYPE=$G(EMBDEF(EMBNAME,"TYPE"),"STRING")
 . S UNIQUE=$G(EMBDEF(EMBNAME,"UNIQUE"),0)
 . S REQ=$G(EMBDEF(EMBNAME,"REQUIRED"),0)
 . S PATTERN=$G(EMBDEF(EMBNAME,"PATTERN"),"")
 . S IXF=$G(EMBDEF(EMBNAME,"INPUTXFORM"),"")
 . S OXF=$G(EMBDEF(EMBNAME,"OUTPUTXFORM"),"")
 . S PRIMARY=$G(EMBDEF(EMBNAME,"PRIMARY"),0) 
 . S MAXLENGTH=$G(EMBDEF(EMBNAME,"MAXLENGTH"),"")
 . ; 
 . ; IF PRIMARY IS SPECIFIED (1), UNIQUE AND REQUIRED
 . ; MUST ALSO BE SPECIFIED
 . ;
 . I PRIMARY=1 D
 . . I UNIQUE=0 D
 . . . D ERR^ROOK(14,.RESULT)
 . . . S ERRCT=$I(ERRCT)
 . . I REQ=0 D
 . . . D ERR^ROOK(14,.RESULT)
 . . . S ERRCT=$I(ERRCT)
 . Q:ERRCT>0
 . S RKRESULT=1
 . ; 
 . ; IF TYPE IS "STRING", "MAXLENGTH" MUST BE SPECIFIED
 . ;
 . I TYPE="STRING" D
 . . I MAXLENGTH="" D ERR^ROOK(21,.RESULT) S ERRCT=$I(ERRCT)
 . Q:ERRCT>0
 . S RKRESULT=1
 . ;
 . ; ADD THE EMBRYO TO THE DATA DICTIONARY
 . ;
 . I RKRESULT=1 D
 . . L ^ROOK("DD",NEST,EGGNAME,"EMBRYOS"):30
 . . I $TEST D 
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"TYPE")=TYPE
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"UNIQUE")=UNIQUE
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"REQUIRED")=REQ
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"PATTERN")=PATTERN
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"INPUTXFORM")=IXF
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"OUTPUTXFORM")=OXF
 . . . S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"PRIMARY")=PRIMARY
 . . . I TYPE="STRING" S ^ROOK("DD",NEST,EGGNAME,"EMBRYOS",EMBNAME,"MAXLENGTH")=MAXLENGTH
 . . E  D
 . . . D ERR^ROOK(20,.RESULT)
 . . L 
 I RKRESULT=1 D SUCCESS^ROOK(.RESULT,0,$$ETIME^ROOK(TIMER),EMBCT,.DATA)
ERMKEMBRYO
 Q RKRESULT
 ;
NESTEXISTS(NEST,RESULT)
 N ERRCT S ERRCT=0
 N DATA S DATA(0)=1
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 . S ERRCT=ERRCT+1
 I $$USED^ROOK="" D
 . D ERR^ROOK(10,.RESULT)
 . S ERRCT=ERRCT+1
 I ERRCT=0 D SUCCESS^ROOK(.RESULT,$D(^ROOK("DD",NEST)),0,0,.DATA)
 Q RKRESULT
 ;
EGGEXISTS(EGG,RESULT)
 N ERRCT S ERRCT=0
 N DATA S DATA(0)=1
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 . S ERRCT=ERRCT+1
 I $$USED^ROOK="" D
 . D ERR^ROOK(10,.RESULT)
 . S ERRCT=ERRCT+1
 I ERRCT=0 D SUCCESS^ROOK(.RESULT,$D(^ROOK("DD",$$CURRENTNEST^ROOK,EGG)),0,0,.DATA)
 Q RKRESULT
 ;
EMBRYOEXISTS(EGGNAME,EMBRYO,RESULT)
 N ERRCT S ERRCT=0
 N DATA S DATA(0)=1
 I '$$CONNECTED^ROOK D
 . D ERR^ROOK(13,.RESULT)
 . S ERRCT=ERRCT+1
 I $$USED^ROOK="" D
 . D ERR^ROOK(10,.RESULT)
 . S ERRCT=ERRCT+1
 I ERRCT=0 D SUCCESS^ROOK(.RESULT,$D(^ROOK("DD",$$CURRENTNEST^ROOK,"EMBRYOS",EMBRYO)),0,0,.DATA)
 Q RKRESULT
 ;